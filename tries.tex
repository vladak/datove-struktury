% Souèást skript na Datové struktury. Viz main.tex
\markright{$ $Id$ $}

\chapter{Trie}

% --------------------------------------------------------------------------
\section{Základní varianta}

Trie je rovinná implementace slovníku.
Máme abecedu $\Sigma$ velikosti $k$. Universum jsou v¹echna slova nad
$\Sigma$ délky právì $l$ (nekoneènou mno¾inu si nemù¾eme dovolit a
krat¹í slova doplníme zprava mezerami). Chceme reprezentovat mno¾inu
slov $S \subseteq U$.

\begin{defn}
\emph{Trie} nad $\Sigma$ je koneèný strom, jeho¾ ka¾dý vnitøní
vrchol má právì $k$ synù, které jsou jednoznaènì ohodnoceny prvky $\Sigma$.
Ka¾dému vnitønímu vrcholu trie odpovídá slovo nad $\Sigma$ délky
nejvý¹e $l$: koøenu
odpovídá prázdné slovo $\Lambda$; kdy¾ vrcholu $v$ odpovídá slovo
$\alpha$, pak $v[a]$, synu $v$ ohodnocenému písmenem $a$, odpovídá
slovo $\alpha a$.
\end{defn}

\newcommand{\Nal}{\textrm{Nal}}
\begin{defn}
Øekneme, ¾e trie nad $\Sigma$ \emph{reprezentuje mno¾inu} $S$, kdy¾:
\begin{itemize}
\item Listùm je pøiøazena boolovská funkce nále¾ení \Nal: $\Nal(t)$ je
  true právì kdy¾ slovo, které odpovídá listu $t$, je v $S$.
\item Kdy¾ $v$ je vnitøní vrchol trie odpovídající slovu $\alpha$, pak
  existuje $\beta \in S$ takové, ¾e $\alpha$ je prefix $\beta$.
\item Pro ka¾dé slovo $\alpha \in S$ existuje v trie list odpovídající
  $\alpha$.
\end{itemize}
\end{defn}

% ..........................................................................
\subsection{Algoritmus MEMBER}

\begin{algorithmic}
\STATE \COMMENT {vyhledání $x = x_1 \dots x_l$}
\STATE $t := \text{koøen}$
\STATE $i := 1$
\WHILE {$t \text{ není list}$}
        \STATE $t := t[x_i]$
        \STATE $i := i + 1$
\ENDWHILE
\STATE \COMMENT {test}
\STATE \textbf{return} $\Nal(t)$
\end{algorithmic}

% ..........................................................................
\subsection{Algoritmus INSERT}

\begin{algorithmic}
\STATE \COMMENT {vyhledej $x$}
\IF[trie nemusí být tak hluboké, jak potøebujeme] {\textbf{not} $\Nal(t)$}
        \WHILE {$i \leq l$}
                \STATE vrcholu $t$ pøidej $k$ listù ohodnocených
                písmeny z $\Sigma$, jejich $\Nal := \textit{false}$
                \STATE $t := t[x_i]$
                \STATE $i := i + 1$
        \ENDWHILE
        \STATE $\Nal(t) := \textit{true}$
\ENDIF
\end{algorithmic}

% ..........................................................................
\subsection{Algoritmus DELETE}

\begin{algorithmic}
\STATE \COMMENT {vyhledej $x$}
\IF {$\Nal(t)$}
        \STATE $\Nal(t) := \textit{false}$
        \STATE $t := \text{otec } t$
        \STATE \COMMENT {opravíme prefixovou podmínku}
        \WHILE {v¹ichni synové $t$ jsou listy s $\Nal = \textit{false}$}
                \STATE zru¹ listy $t$
                \STATE $\Nal(t) := \textit{false}$
                \STATE $t := \text{otec } t$
        \ENDWHILE
\ENDIF  
\end{algorithmic}

Pou¾ili jsme obrat $t := \text{otec } t$. To lze provést buï tak, ¾e
se vrchol kromì svých synù odkazuje i na svého otce a spotøebuje tak
pamì» navíc, nebo se cesta z koøene do aktuálního vrcholu bìhem
sestupu ve stromu pamatuje na zásobníku. Tento trik se pou¾ívá u 
v¹ech stromových struktur.

% ..........................................................................
\subsection{Èasová a pamì»ová slo¾itost}

Jedna iterace cyklu zabere konstantní èas. Èas pro MEMBER je $O(l)$,
èas pro INSERT a DELETE je $O(l k)$. Pamì»ová slo¾itost trie je poèet
ulo¾ených slov násobená délkou cesty a poètem synù, tedy $O(|S| l k)$.

% --------------------------------------------------------------------------
\section{Komprimované trie}

Mìjme $\Sigma = \{0,1,2\}$, $l=7$.
$S = \{0202011, 0202012, 0202021, 1212102, 1212111, 1212121, 1212122\}$.
Nekomprimované trie pro tuto mno¾inu je na obrázku \ref{fig:tries}.
Vidíme, ¾e písmena na druhé a¾ páté pozici jsou v¾dy stejná a
pøedchozí algoritmy se jimi musí \uv{prokousat}. Pøesnì 
øeèeno, prohlí¾ení vrcholu $v$, který má jediného 
syna, který není list s funkci $\Nal = \textit{false}$, nepøiná¹í 
¾ádnou kladnou informaci, proto¾e mno¾iny prvkù z $S$, 
které jsou reprezentovány vrcholy v podstromu otce $v$ a v podstromu 
vrcholu $v$ jsou stejné. To vedlo k idei tyto vrcholy ze stromu vynechat a tím 
zmen¹it (kompresovat) trie.  
   
\begin{figure}
\centering\includegraphics{pics/tries}
\caption{Nekomprimované trie}
\label{fig:tries}
\end{figure}

\newcommand{\uro}{\textrm{uroven}}
Ke ka¾dému vrcholu $v$ pøidáme funkci $\uro(v)$ vyjadøující èíslo úrovnì,
ve které se $v$ nachází v pùvodním trie.
\newcommand{\slo}{\textrm{slovo}}
Ke ka¾dému listu $v$ pøidáme funkci $\slo(v)$ --- slovo, které odpovídá $v$.

Nyní mù¾eme vynechávat vrcholy podle následujícího kritéria: 
je-li $v$ vnitøní vrchol a v¹ichni jeho synové kromì $w$ jsou listy s
$\Nal = \textit{false}$, pak $v$ vynech a zaøaï $w$ na jeho místo. Tento proces 
opakujeme dokud trie obsahuje nìjaký vnitøní vrchol, jeho¾ v¹ichni synové 
s výjimkou jednoho jsou listy, pro nì¾ $\Nal = \textit{false}$. V¹imnìte si, ¾e 
ka¾dý vnitøní vrchol má právì $k$ synù, které jsou v jednoznaèné 
korespondenci s písmeny abecedy $\Sigma$.

% ..........................................................................
\subsection{MEMBER}

Viz algoritmus \ref{alg:trie.k.mem}

\begin{algorithm}[!htb]
\caption{MEMBER pro komprimované trie}
\label{alg:trie.k.mem}
\begin{algorithmic}
\STATE \COMMENT {vyhledání $x$}
\STATE $t := \text{koøen}$
\WHILE {$t \text{ není list}$}
        \STATE $i := \uro(t) + 1$
        \STATE $t := t[x_i]$
\ENDWHILE
\STATE \COMMENT {test}
\STATE \textbf{return} $\Nal(t) \land \slo(t) = x$
\end{algorithmic}
\end{algorithm}

zde \mnote{nìco chybí}
% ..........................................................................
\subsection{INSERT}

Viz algoritmus \ref{alg:trie.k.ins}

\begin{algorithm}
\caption{INSERT pro komprimované trie}
\label{alg:trie.k.ins}
\begin{algorithmic}
\STATE \COMMENT {vyhledej $x$}
\IF {$\Nal(t) \land \slo(t) = x$}
	\STATE \COMMENT {Trie u¾ obsahuje $x$, nedìlej nic.}
\ELSE
        \IF {$\slo(t) = x$}
		\STATE \COMMENT {Trie obsahuje správný list,
		pouze nastav pøíznak. Napø. "0202010"}
                \STATE $\Nal(t) := \textit{true}$
	\ELSE
		\STATE \COMMENT {Bude potøeba vlo¾it nový list.}
		\STATE \COMMENT {Najdi, kam ho pøipojit.}
                \STATE $\alpha$ := nejdel¹í spoleèný prefix slov
		$x$ a $\slo(t)$. Délku $\alpha$ oznaème $|\alpha|$.
                \STATE $v$ := vrchol na cestì z koøene do $t$ takový,
                ¾e $\uro(v)$ je nejvìt¹í, která je $\leq |\alpha|$
                \IF {$\uro(v) = |\alpha|$}
                        \STATE \COMMENT {$v$ je otec nového listu}
		\ELSE[$\uro(v) < |\alpha|$]
                        \STATE \COMMENT {Bude potøeba vytvoøit
			otce nového listu}
                        \STATE $a$ := $\uro(v)+1$-ní písmeno $\alpha$
                        \STATE $u := v[a]$
                        \STATE \COMMENT {Mezi $v$ a $u$ vytvoø nový
			vnitøní vrchol odpovídající slovu $\alpha$}
                        \STATE $w$ := nový vrchol, $\uro(w) := |\alpha|$
                        \STATE $v[a] := w$
                        \STATE $c$ := $|\alpha|+1$-ní písmeno $\slo(t)$
                        \STATE $w[c] := u$
                        \FORALL {$b \in \Sigma, b \neq c$}
                             \STATE $z$ := nový vrchol, $\uro(z) := |\alpha|+1, \Nal(z) := \textit{false}, \slo(z) := \alpha b$, 
                             \STATE $w[b] := z$
                        \ENDFOR
                        \STATE $v := w$
                \ENDIF
		\STATE \COMMENT {Správnému listu pøiøaï $x$}
		\STATE $d$ := $|\alpha|+1$-ní písmeno $x$
                \STATE $s := v[d]$
                \STATE $\uro(s) := l, \Nal(s) := \textit{true}, \slo(s) := x$
        \ENDIF
\ENDIF
\end{algorithmic}
\end{algorithm}

% ..........................................................................
\subsection{DELETE}

Viz algoritmus \ref{alg:trie.k.del}

\begin{algorithm}[!htb]
\caption{DELETE pro komprimované trie}
\label{alg:trie.k.del}
\begin{algorithmic}
\STATE \COMMENT {vyhledej $x$}
\IF {$\Nal(t) \land \slo(t) = x$}
        \STATE $u$ := otec $t$
        \STATE $i := \uro(u)$
        \STATE $\Nal(t) := \textit{false}$
        \STATE $\uro(t) := i+1$, $\slo(t)$ := prefix slova $x$ délky $i+1$
        \STATE \COMMENT {vrchol $u$ má alespoò jednoho syna, který není list s $\Nal = \textit{false}$}
        \IF {v¹ichni synové $u$ kromì syna $w$ jsou listy s $\Nal = \textit{false}$}
                \STATE $v$ := otec $u$
                \STATE sma¾ $u$ a v¹echny syny $u$ kromì $w$
                \STATE $j := \uro(v) + 1$
                \STATE $v[x_j] := w$ (tj. $x_j$-tý syn v je w)
        \ENDIF
\ENDIF  
\end{algorithmic}
\end{algorithm}

% ..........................................................................
\subsection{Èasová a pamì»ová slo¾itost}

Pamì»ová slo¾itost takto komprimovaných trie je $O(nl+kl)$, kde 
$n$ je velikost reprezentované mno¾iny.
Èasová slo¾itost operací MEMBER, INSERT a DELETE je v nejhor¹ím
pøípadì $O(l)$ a v prùmìrném pøípadì (za pøedpokladu rovnomìrného
rozlo¾ení vstupních dat) je to oèekávaná hloubka trie. Tu
teï spoèítáme.

Nech»
\[
q_d = \pr(\text{trie má hloubku alespoò $d$})
\]
Oèekávaná hloubka trie reprezentující $n$ slov je
\[
E_n = \sum_{d=0}^\infty d (q_d - q_{d+1}) = \sum_{d=0}^\infty q_d
\]
Kdy¾ funkce $\text{pref}_{d-1}$, pøiøazující slovu 
$\alpha$ jeho prefix délky $d-1$, je na mno¾inì $S$ prostá,
pak trie reprezentující mno¾inu $S$ má hloubku nejvý¹e $d$.
Spoèítáme poèet mno¾in o velikosti $n$, na nich¾ je funkce $\text{pref}_{d-1}$ 
prostá. Tyto mno¾iny získáme tak, ¾e vybereme $n$ prefixù délky $d-1$
a ka¾dý doplníme v¹emi sufixy délky $l-d+1$. Proto tìchto mno¾in je
\[
\binom{k^{d-1}}{n} k^{n (l-d+1)}.
\]
Proto¾e v¹ech podmno¾in velikosti $n$ je $\binom{k^l}{n}$ dostáváme, ¾e 
\begin{align*}  
q_d 
 &\leq 1 - \frac{\binom{k^{d-1}}{n} k^{n (l-d+1)}}{\binom{k^l}{n}}\\
 &\leq 1 - \frac{k^{d-1}(k^{d-1}-1)\dots(k^{d-1}-(n-1)) k^{n(l-d+1)}}{k^{ln}}\\
 &   = 1 - \prod_{i=0}^{n-1} \left( 1 - \frac{i}{k^{d-1}} \right) \\
 &\leq 1 - \exp\left( \frac{-n^2}{k^{d-1}} \right)\\
 &\leq \frac{n^2}{k^{d-1}},
\end{align*}
ponìvad¾
\begin{align*}
                  \prod_{i=0}^{n-1}    \left( 1 - \frac{i}{k^{d-1}} \right)
 &   = \exp\left( \sum_{i=0}^{n-1} \ln \left( 1 - \frac{i}{k^{d-1}} \right)
	   \right)\\
 &\geq \exp\left(         \int_0^n \ln \left( 1 - \frac{i}{k^{d-1}} \right)
	   \right)\\
 &   = \exp\left( \frac{-n^2}{k^{d-1}} \right),
\end{align*} 
(u¾ijte integrální kriterium a substituci $x = k^{d-1}(1-t)$) a 
$e^x - 1 \geq x$ (odtud $1 - e^x \leq -x$). Tedy pro $c = 2\lceil\log_kn\rceil$ 
dostáváme
\begin{align*}
E_n
 & = \sum_{d=1}^cq_d + \sum_{d=c+1}^{\infty}q_d\\
 &\leq c + \sum_{d=c}^{\infty}\frac{n^2}{k^d}\\
 &\leq 2\lceil\log_kn\rceil +
		\left( \frac{n^2}{k^c} \right) \sum_{d=0}^{\infty} k^{-d}\\
 &\leq 2\lceil\log_kn\rceil + \frac{1}{1-1/k}\\
 & = 2\lceil\log_kn\rceil + \frac{k}{k-1}.
\end{align*}

Tedy oèekávaný èas operací MEMBER, INSERT a DELETE pro komprimované 
trie (za pøedpokladù rovnomìrného rozlo¾ení vstupních dat) 
je $O(\frac{\log n}{\log k})$. Zde parametr $k$ vyjadøuje vztah mezi prostorovými 
a èasovými nároky.

% . . . .. . . .. .. .. . .  . .. .. .. . . ..  ..  .... . . .. . .. . .
% nasledujici sekci (jeste kompr. trie atd.) dopsal Vladimir Kotal, 2003

\mnote{XXX k cemu patri nasl. algoritmus ? (Koubek 2002)}
INSERT($x=x_1, ..., x_l$)
\begin{algorithmic}
\STATE t <- koøen
\WHILE {t neni list}
  \STATE i <- hladina(t), t <- $(a_{i+1})$-ní syn t
\ENDWHILE
\IF {prvek(t) neni prefix x}
  \STATE beta = nejvetsi spolecny prefix x a prvek(t)
  \STATE beta a = prefix alfa
  \STATE beta b = prefix prvek(t)
  \STATE while hladina(t) > |beta| do t <- otec(t) done
  \IF {hladina(t) < |beta|}
    \STATE vytvorime novy vrchol w, jehoz synove, krome b-teho syna budou listy s
    \STATE funkcemi Nal = false
    \STATE prvek(t) = beta + oznaceni syna
    \STATE hladina(w) = |beta|, beta = $(a_1, ..., a_i)$
    \STATE necht $v = a_{hladina(t) + 1}$ - tý syn t, b-ty syn w je v
    \STATE $w = a_{hladina(t)+1}$-tý syn t
  \ENDIF
  \STATE z <- a-ty syn t, Nal(z) = true, prvek(z) = x
\ELSE
  \STATE Nal(t) = true, prvek(t) = x
\ENDIF
\end{algorithmic}

\mnote{XXX dalsi neznamy algoritmus z prednasky 2002}

DELETE($x=x_1, ..., x_l$)
\begin{algorithmic}
\STATE t <- koren
\WHILE {t neni list}
  \STATE i <- hladina(t), t <- $(a_{i+1}$-ni syn t
\ENDWHILE
\IF {Nal(t) = true a prvek(t) = j} 
  \STATE Nal(t) = false
  \STATE v <- otec(t)
  \STATE prvek(t) <- prefix prvek(t) o delce hladina v+1
  \IF {vsichni synove vrchovlu v az na jednoho jsou listy s Nal = false}
    \STATE w <- syn(v), ktery je bud list s Nal(w) = true nebo neni list
    \STATE necht v je a-ty ($a_i$-ty ???) syn sveho otce, v smazeme a smazeme
    \STATE vsechny syny $v \neq w$
    \STATE w <- a-ty ($a_i$-ty ???) syn otce v
  \ENDIF
\ENDIF
\end{algorithmic}


\section{Je¹tì komprimovanìj¹í trie}

% XXX dopsat !
Pø:

mìjme násedující komprimovaný trie:

% XXX obr.
\mnote{tady chybí obrázek}

a jeho matici:
\par

\begin{tabular}{l|l|l|l|}
 & 0 & 1 & 2 \\
\hline
root & NIL & a & b \\
a & 102 & NIL & c \\
b & 210 & 211 & 212 \\
c & 120 & 121 & NIL \\
\hline
\end{tabular}

Chceme se zbavit polo¾ek NIL v matici reprezentující trie. Dal¹í komprese
dosáhneme pomocí vektorù hod (vektor hodnot) a rd. Tyto vektory budou
reprezentovat pùvodní matici.

% XXX co znamena rd ?

\subsection{Popis $A$ a $rd$}

Zpìt k na¹emu pøíkladu: \
I. \\
\begin{tabular}{|lllllll|}
\hline
hod & 210 & 211 & 212 & 120 & 121 & NIL \\
rd & root & a & b & c \\
 & & & 0 & 3 \\
\hline
\end{tabular}

II. \\
\begin{tabular}{|lllllllllll|}
\hline
hod & 210 & 211 & 212 & 120 & 121 & a & b & 102 & NIL & c \\
rd & root & a & b & c \\
 & 4 & 7 & 0 & 3 \\
\hline
\end{tabular}


Øádek i zaèíná na místì rd(i) a musí být splnìna podmínka: \\
Kdy¾ $M_{i,j} \neq NIL \neq M_{i',j'}$, pak $rd(i) + j \neq rd(i') + j'$ \\
Kdy¾ na místì hod chceme zapsat prvek $\neq NIL$ a NIL, pak zapí¹eme prvek
$\neq NIL$.


\subsection{Algoritmus pro hledání rd a hod}
M - matice typu r x s, má m význnamných míst $\neq$ NIL

- pro ka¾dý øádek nalezneme poèet míst $\neq$ NIL
- setøídíme øádky Bucketsortem, tak ¾e rádky s vìt¹ím poètem míst $\neq$ NIL
  pøedcházejí øádky s men¹ím poètem míst $\neq$ NIL
- procházíme øádky v daném setøídìní a pro ka¾dý øádek i nalezneme
  nejmen¹í èíslo rd(i), ¾e nedochází ke kolizi s pøedchozími øádky (tj.
  kdy¾ $M_{i',j'} \neq NIL \neq M_{i,j}$) a øádek i' byl zaøazen, pak
  $rd(i) + j \neq rd(i') + j'$.
  Pak $M_{i,j} \neq NIL$ je ulo¾eno ve vektoru hod na místì rd(i)+j.

m(l) - poèet míst $\neq$ NIL v øádcích s poètem míst $\geq l+1 \neq NIL$.

\begin{theorem}
Kdy¾ $m(l)(l+1) \leq m$ pro ka¾dé l, pak $rd(i) < m$ pro ka¾dý øádek i a
algoritmus vy¾aduje èas O(rsm).
\end{theorem}

\begin{proof}
Pøedpokládejme, ¾e hledáme rd pro øádek i, který má l míst $\neq NIL$. \\
ve vektoru hod je obsazeno ménì ne¾ m(l-1) míst. \\ 
zkou¹íme rd(i)=1,2,... \\
rd(i) = 1,2,... je zakázané, kdy¾ vznikne kolize. \\
tj. $\exists$ øádek i' pøedcházející a $\exists j,j'$ takové, ¾e $M_{i',j'} \neq
NIL \neq M_{i,j}$ a platilo by $rd(i') + j' = rd(i) + j$.
$\leftarrow$ tìchto mo¾ností je $< lm(l-1) \leq m$. \\
O(rs) - zjistíme pro ka¾dý øádek poèet míst $\neq NIL$.
O(m+r) - tøídìní Bucketsortem
O(mrs) - krok 2
\end{proof}

Pø:
jedna mo¾nost

% XXX obr. matice
M = 

$\leftarrow$ budeme mít moc øádkù - nevhodné

Pø:\\

\begin{tabular}{|l|lll|}
\hline
M & 0 & 1 & 2 \\
\hline
root & NIL & a b \\
a & 102 & NIL & c \\
b & 210 & 211 & 212 \\
c & 120 & 121 & NIL \\
\hline
\end{tabular}

rd root a b c
   4    7 0 3
hod 210 211 212 120 121 a b 102 NIL c

\begin{tabular}{|l|lll|}
\hline
M' & 0 & 1 & 2 \\
\hline
b & 210 & 211 & 212 \\
c & 120 & 121 & NIL \\
root & NIL & a b \\
a & 102 & NIL & c \\
\hline
\end{tabular}

(pøehodili jsme pouze øádky)

\begin{tabular}{|lll|}
\hline
210 & NIL & NIL \\
120 & 211 & 212 \\
NIL & 121 & NIL \\
102 & a & b \\
NIL & NIL & c \\
\hline
\end{tabular}


\subsection{Vertikální posun sloupcù}

cd - vektor sloupcového posunutí, slou¾í k zápisu transformace

\begin{tabular}{l|lll|}
\hline
 & 0 & 1 & 2 \\
cd & 0 & 1 & 2 \\
\hline
\end{tabular}

\begin{tabular}{l|lllll|}
\hline
 & 0 & 1 & 2 & 3 & 4 \\
rd & 6 & 0 & 6 & 3 & 6 \\
\hline
\end{tabular}

hod 120 211 212 102 a b 210 121 c

Jak najdeme nazpátek místa ? Platí, kdy¾ $M_{i,j} \neq NIL$, pak
$hod(rd(i+cd(j)+j)) = M_{i,j}$
\mnote{je ten vzorec správnì ?}

znaèení: 
f(-,-) je fce dvou promìnných
$B_j$ matice posunutých prvních sloupcù
$m_j$ poèet míst $\neq NIL$ v $B_j$
$m_j(l)$ poèet míst $\neq NIL$ v øádcích matice $B_j$, které mají aspoò l+1 míst
$\neq NIL$
\par

Budeme chtít, aby $\forall j \forall l platilo m_j(l) \leq
\frac{m}{f(l,m_j)}$. \\
okrajové podmínky na f: f musí splòovat:
\begin{itemize}
\item $\forall$ l platí $f(l,m) \geq l+1$
\item$\forall$ j platí $f(0,m_j) \leq \frac{m}{m_j}$
\end{itemize}

\subsubsection{Algoritmus na posunutí sloupcù}

1) pro ka¾dý sloupec v poøadí 0,1,... nalezneme nejmen¹í cd(j) takové, aby
matice $B_j$ splòovala $\forall l m_j(l) \leq \frac{m}{f(l,m_j)}$
(ka¾dý sloupec posunujeme dokud nesplòuje podmínku)
na získanou matici $B = B_s$ pak pou¾ijeme pøedchozí algoritmus
Platí $m(l) = m_s(l) \leq \frac{m}{f(l,m)} \leq \frac{m}{l+1}$
Hledáme hodnotu cd(j) a pøedp., ¾e pro nìjakou hodnotu cd(j) není splnìna
podmínka pro l, tj. platí $m_j(l) > \frac{m}{f(l,m)}$
... platila pro $B_{j-1}, tj. m_{j-1}(l) \leq \frac{m}{f(l,m_{j-1})}$

Z toho plyne $m_j(l) - m_{j-1}(l) > \frac{m}{f(l,m_j)} -
\frac{m}{f(l,m_{j-1}}$.

Jak roste èíslo $m_j(l)$ ? \\
\begin{itemize}
\item v matici $B_{j-1}$ existuje øádek s aspoò l+1 místy $\neq NIL$ a s tímto
øádkem se støetne místo $\neq NIL$ (v j-tém sloupci $\leftarrow
m_{j-1}(l)$
vzroste o 1)
\item v matici $B_{j-1}$ existuje øádek s l místy $\neq NIL$ a s tímto øádkem
se støetne místo $\neq NIL$ v j-tém sloupci. Pak $m_{j-1}(l)$ vzroste o l+1.
\end{itemize}

støet - øádek v $B_{j-1}$ s aspoò l místy $\neq NIL$ a místo $\neq NIL$ v j-tém
sloupci. Aby nebyla splnìna podmínka pro l, musí pro danou hodnotu cd(j)
být aspoò $\frac{\frac{m}{f(l,m_j)} - \frac{m}{f(l,m_{j-1})}}{l+1}$ 
støetù.
\par
V matici $B_{j-1}$ je nejvý¹e $\frac{m_{j-1}(l-1)}{l} \leq \frac{m}{l
f(l-1,m_{j-1}}$ øádkù s aspoò l místy $\neq NIL$, v j-tém sloupci je $m_j -
m_{j-1} míst \neq NIL$. \\
Podmínku pro l mù¾e zakázat nejvý¹e 
$\frac{ \frac{m(m_j - m_{j-1})}{l f(l-1,m_{j-1}} }
      { \frac{ \frac{m}{f(l,m_j} - \frac{m}{f(l,m_{j-1}} }{l+1} }$
hodnot cd.
\par

Staèí nám sèítat pøes hodnoty l takové, ¾e \\
$m m_{j-1}(l) \leq l-1$ tj. pøes 
$l \leq l_0 = min{l| \frac{m}{f(l,m_{j-1}} < l}$
$m_{j-1}(l) \leq \frac{m}{f(l,m_{j-1})} \leq l+1$.

Celkový poèet zakázaných hodnot cd je men¹í ne¾ \\
$\sum_{l=1}^{l_0} \frac{l+1}{l} \frac{(m_j - m_{j-1})}{
\frac{f(l,m_{j-1}}{f(l,m_j)} - 1} \frac{f(l,m_{j-1}}{f(l-1,m_{j-1}} $
(*)
% XXX zavest si nejake cislovani

Zvolíme $f(l,m_j) = 2^{l(2 - \frac{m_j}{m}}$
\mnote "mystika"
f splòuje okrajové podmínky
$f(l,m) = 2^l \geq l+1 \forall l=0,1,...$ \\
$f(0,m_j) = 1 \leq \frac{m}{m_j} \forall j=0,1,...,s$

dosadíme do odhadu (*)
% XXX doplni cislovani
a dostaneme 

$$
\sum_{l=1}^{l_0} 
  \frac{l+1}{l} 
  \frac
    {(m_j - m_{j-1})}
    { 2^{l ( \frac{m_j}{m} - frac{m_{j-1}}{m} ) }}
  2^{( 2 - \frac{m_{j-1}}{m} )} \leq 
\sum_{l=1}^{l_0} 
  \frac{l+1}{l} 
  \frac{(m_j - m_{j-1})}{l( \frac{m_j}{m} - frac{m_{j-1}}{m} )} 4 = \\
\frac{4m}{ln(2)} \sum_{l=1}^{l_0} 
  \frac{l+1}{l^2} = \frac{4m}{ln(2)} (\sum_{l=1}^{l_0} \frac{1}{l} +
  \sum_{l=1}^{l_0} \frac{1}{l^2}) \leq 
% XXX integr. krit
\frac{4m}{ln(2)} (1 + ln(l_0)) + \frac{\pi^2}{6} \leq 4m log_2(l_0) +
15.3m
$$

$l_0 = min{l; \frac{m}{f(l,m_{j-1}} < l} \leftarrow l_0 < log(m) $
$\leftarrow \leq 4m log(log(m)) + 15.3m$

Celý algoritmus spoèítá ulo¾ení matice M typu r x s do vrcholù cd -
dimenze s, rd - dimenze $4m log(log(m)) + 15.3m + r$ a hod dimenze m+s,
pøitom hodnoty $cd(j) < 4m log(log(m)) + 15.3m$ a $rd(i) < m$.
\par
Èas potøebný k výpoètu je $O(sr(m loglog(m))^2)$, kde m je poèet míst $\neq
NIL$ v matici M.

\subsection{Úsporné ulo¾ení øídkého vektoru}

Mámme vektor v dimenze $n \cdot d$ a $i_0 < i_1 < ... < i_{+}$ jsou v¹echny
indexy i takové, ¾e $v(i) \neq 0$. \\
Vytvoøíme vektor cv dimenze t, $cv(j)=v(i_j)$.
ná¹ úkol - pro dané l zjistit, zda $l = i_j$ a pøípadnì nalézt toto j.
base - dimenze m

% XXX sloz. zavorka
base(j) = -1 kdy¾ $i_k div d \neq j \forall k=0,1,...,t-1$
          $min{l; i_l div d = j}$ kdy¾ $\exists l, ¾e i_l div d = j$

vektor offset - dimenze n x d
% opet sloz. zavorka
offset(j,k) = -1 kdy¾ $i_l \neq jd+k \forall l = 0,1,...,t-1$
   	      $l-base(j)$ kdy¾ $i_l = jd+k$

\mnote{jd+k ... zápis v d-èkové soustavì}

vektor off(j) = $\sum_{k=0}^{d-1}(offset(j,k) + 1)(d+1)^k$ \\
off je dimenze n \\
smysluplné kdy¾ $d << n a t < n$ (napø. d = loglogn)


