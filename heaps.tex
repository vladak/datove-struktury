% ==========================================================================
% prednaska DS 7.4.2003

\chapter{Haldy}

\begin{defn}
Haldy jsou stromové struktury, které splòují 
\begin{itemize}
\item lokální podmínku na uspoøádání
  - prvek reprezentující otce je men¹í ne¾ prvek reprezentovaný synem
    apod.
% oprava by M. Macok:
% "strukturalni podminky" na stromy jsou podminky na tvar
% stromu (event. lesu), podle kterejch se ty haldy rozdelujou na Fib.,
% leftlist apod... neni tam nic o tom, jestli jsou synove vetsi/mensi
% nez otcove apod., od toho je tam ta prvni podminka...
\item strukturální podmínku na stromy, ze kterých jsou vytvoøené 
\end{itemize}
\end{defn}

\begin{pozn}
Podle tìchto podmínek se haldy rozdìlují na Fibonacciho, Leftist,
d-regulární apod. (mohou se li¹it jak lokální, tak strukturální podmínkou)
\end{pozn}

% --------------------------------------------------------------------------
\section{$d$-regulární haldy}

\begin{defn}
d-regulární halda, $d$ celé èíslo $d \geq 2$ \\
Je to strom $T$ takový, ¾e existuje jednoznaèná korespondence mezi vrcholy
stromù a prvky reprezentované mno¾iny a platí:
\begin{enumerate}
\item strom $T$ splòuje strukturální podmínky:
  \begin{itemize}
    \item ka¾dý vrchol s vyjímkou nejvý¹e jednoho je buï list nebo má $d$ synù
    \item ka¾dý vrchol má nejvý¹e $d$ synù
    \item existuje oèíslování synù ka¾dého vrcholu tak, ¾e po oèíslování
  	  prùchodem ¹íøky platí: \\
	  kdy¾ vrchol není list, pak ka¾dý vrchol s men¹ím èíslem má $d$
	  synù.
	  %\footnote{Tato podmínka øíká jinými slovy toto: V poslední
	  %hladinì jsou v¹echny uzly umístìny co mo¾ná nejvíce "vlevo",
	  %tzn. procházíme-li uzly pøedposlední hladiny zleva doprava,
	  %nejprve má nìkolik z nich (popø. ¾ádný) $d$ následníkù, pak mù¾e
	  %být (ale nemusí) jeden uzel s jedním následníkem a zbývající 
	  %uzly pøedposlední hladiny následníky
	  %nemají. (parafráze z~\cite{Topfer}, str.~79)}.
  \end{itemize}
  \item podmínku na lokální uspoøádání: \\
	kdy¾ $x$ je prvek pøiøazený vrcholu $t$, pak otci($t$) je pøiøazen
	prvek $\leq x$ pak po oèíslování prùchodem do ¹íøky platí:
	kdy¾ vrchol má èíslo $i$, jeho synové mají èísla
% oprava by M.Macok :
% strana 70, prvni syn vrcholu neni na pozici d(i-1)+1 ale ..+2
	$d(i-1)+2,d(i-1)+3,...,di+1$ a otec má èíslo 
	$\lceil\frac{i-1}{d}\rceil$.
\end{enumerate}
\end{defn}

\begin{priklad}
Pøíklad 3-regulární haldy je na obrázku~\ref{XXX}.

\mnote{XXX chybi obr.}

Kdy¾ takto oèíslované prvky dáme do pole, pak platí: kdy¾ je vrchol na
$i$-tém místì, èísla synù jsou $3(i-1)+2, 3i, 3i+1$
a otec je na $\lceil\frac{i-1}{3}\rceil$ místì v poli.
to vyu¾ijeme pro implementaci polem - u¹etøíme místo.
\end{priklad}

\begin{pozn}
Nejpopulárnìj¹í jsou 2-reg. haldy, proto¾e synové i-tého vrcholu
jsou na místech $2(i-1)+2=2i, 2(i-1)+3=2i + 1$, otec je na
$\lceil\frac{i-1}{2}\rceil + 1 = \lceil\frac{i}{2}\rceil$. 
$\Rightarrow$ snadné poèítání (bitový posun)
\end{pozn}

\subsection{Algoritmus UP}

Operace UP($x$) srovná haldu smìrem nahoru.

\begin{algorithm}[!htb]
\caption{UP pro d-regulární haldy}
\label{alg:heap.dreg.up}
\begin{algorithmic}
\STATE A: 
\IF {prvek reprezentovaný $x$ je $<$ prvek reprezentovaný otcem($x$)} 
  \STATE $x$ a otce($x$) vymìníme 
  \STATE pokraèujeme v A
\ENDIF
\end{algorithmic}
\end{algorithm}


\subsection{Algoritmus DOWN}

\begin{algorithm}[!htb]
\caption{DOWN pro d-regulární haldy}
\label{alg:heap.dreg.down}
\begin{algorithmic}
\STATE A:
\IF {prvek reprezentovaný $x >$ prvek reprezentovaný nìkterým synem $x$}
  \STATE vymìníme $x$ a syna $x$, který reprezentuje nejmen¹í prvek,
  \STATE pokraèujeme v A
\ENDIF
\end{algorithmic}
\end{algorithm}

\begin{pozn}
Kdy¾ má hlada hloubku $h$, pak UP($x$) vy¾aduje èas $O(h)$, DOWN($x$) èas
$O(dh)$.
\end{pozn}

\subsection{Operace na haldì}

\subsubsection{INSERT}

\begin{algorithm}[!htb]
\caption{INSERT pro d-regulární haldy}
\label{alg:heap.dreg.insert}
\begin{algorithmic}
\STATE pøidáme poslední list $t$ reprezentující $x$
\STATE UP($t$)
\end{algorithmic}
\end{algorithm}

\subsubsection{MIN}

\begin{algorithm}[!htb]
\caption{MIN pro d-regulární haldy}
\label{alg:heap.dreg.min}
\begin{algorithmic}
\STATE vrátí prvek reprezentovaný v koøeni
\end{algorithmic}
\end{algorithm}

\subsubsection{DELETEMIN}

viz algoritmus~\ref{alg:heap.dreg.deletemin}.

\begin{algorithm}[!htb]
\caption{DELETEMIN pro d-regulární haldy}
\label{alg:heap.dreg.deletemin}
\begin{algorithmic}
\STATE prvek reprezentovaný posledním listem dáme do koøene
\STATE odstraníme poslední list 
\STATE DOWN(koøen)
\end{algorithmic}
\end{algorithm}

\subsubsection{DECREASEKEY$(x, \Delta)$}

Provedení této operace pøedpokládá, ¾e musíme znát polohu vrcholu $t$
reprezentujícího $x$, toto halda neumo¾òuje nalézt. 

viz algoritmus~\ref{alg:heap.dreg.decrkey}.

\begin{algorithm}[!htb]
\caption{DECREASEKEY pro d-regulární haldy}
\label{alg:heap.dreg.decrkey}
\begin{algorithmic}
\STATE zmìníme uspoøádání v bodì $x$ 
\STATE UP($x$) mohl by být men¹í ne¾ jeho otec, proto provedeme UP 
\end{algorithmic}
\end{algorithm}

\subsubsection{INCREASEKEY$(x, \Delta)$}

Musíme znát polohu vrcholu $t$ reprezentujícího $x$, 
toto halda neumo¾òuje nalézt. 
viz algoritmus~\ref{alg:heap.dreg.incrkey}.

\begin{algorithm}[!htb]
\caption{INCREASEKEY pro d-regulární haldy}
\label{alg:heap.dreg.incrkey}
\begin{algorithmic}
\STATE zmìníme uspoøádání v bodì $x$ 
\STATE DOWN($x$)
\end{algorithmic}
\end{algorithm}

\subsubsection{DELETE}

Musíme znát polohu vrcholu $t$ reprezentujícího $x$, toto halda neumo¾òuje
nalézt.
\par
Vezmeme prvek $y$ reprezentovaný posledním listem, odstraníme poslední list,
prvek $t$, který reprezentoval $x$ bude reprezentovat $y$.


\begin{algorithm}[!htb]
\caption{DELETE pro d-regulární haldy}
\label{alg:heap.dreg.delete}
\begin{algorithmic}
\IF {$y < x$} 
  \STATE UP($t$) else DOWN($t$) 
\ENDIF
\end{algorithmic}
\end{algorithm}

\subsection{Algoritmus MAKEHEAP}

Dána prostá posloupnost $x_1, x_2, ..., x_n$.
Chceme vytvoøit d-reg. haldu reprezentující mno¾inu 
${ x_1, x_2, ..., x_n }$. Vezmeme "d-reg. strom" $T$ s vrcholy pøiøadíme
prvky $x_1, x_2, ..., x_n$. Pro v¹echny vrcholy, které nejsou listy podle
oèíslování v poøadí od nejvìt¹ího k nejmen¹ímu provedeme DOWN($t$).
\par

\mnote{chybí obrázek}
% XXX obr.

Invariant: v okam¾iku, kdy provádím DOWN($t$), tak vrcholy, které
reprezentující vìt¹í prvky splòují smìrem dolù podmínku 

\subsection{Slo¾itost operací}

V d-reg. haldì reprezentující n-prvkovou mno¾inu implementace operací
vy¾aduje èasy dané tabulkou:

\begin{center}
\begin{tabular}{|l|l|}
\hline
Operace & Slo¾itost \\
\hline
MIN & O(1) \\
INSERT, DECREASEKEY & $O(log_d(n))$ \\
DELETEMIN, INCREASEKEY, DELETE & $O(d \cdot log_d(n))$ \\
\hline
\par
\end{tabular}
\end{center}

Máme vrchol v $i$-té hladinì a "d-reg. strom" má hloubku $h$. 
Kolik èasu potøebuje DOWN($t$) ?
Je to $O(d(h-1))$.
\par
Poèet vrcholù v $i$-té hladinì je $di$. \\
Èas MAKEHEAP je 
$O(\sum{i=0}{h-1} d^id(h-i)) = O(dS)$, kde 
$$
S = \sum{i=0}{h-1}d^i(h-i)
$$

Budeme poèítat 
\begin{multline}\bigparens
dS - S = \sum{i=0}{h-1}d^{i+1}(h-i) - \sum{i=0}{h-1}d^{i}(h-i) = \\
d^h - h + \sum{i=0}{h-1}d^{i}(h-i-(h-i-1)) = d^h - h\frac{d^h - 1}{d-1} \\
\Rightarrow S = \frac{d^h - h}{d-1} + d\frac{d^{h-1} - 1}{(d-1)^2}, 
h = log_d(n) \Rightarrow S \approx O(\frac{n}{d})
\end{multline}


\subsection{Dijkstrùv algoritmus}

K èemu jsou d-reg. haldy dobré ? napø. pro implementaci Dijkstrova
algoritmu.
\par

\begin{itemize}
\item[Vstup:] orientovaný graf $(V,E)$, fce $c:E \rightarrow R^+$, vrchol $z$
\item[Výstup:] $d(v)$, $v \in V$ \\
	$d(v)$ je délka nejkrat¹í cesty ze $z$ do $v$ \\
\end{itemize}

\begin{algorithm}[!htb]
\caption{Dijkstrùv algoritmus pro d-regulární haldy}
\label{alg:heaps.d-reg.dijkstra}
\begin{algorithmic}
\STATE $d(z) = 0, d(v) = \infty \forall v \in V, v \neq z, U = {z}$\\
\WHILE {$U \neq \emptyset$}
  \STATE vezmeme z $U$ prvek $u \in U$ s nejmen¹í hodnotou $d(u)$,
    \STATE odstraníme ho z $U$.
  \FOR {$\forall(u,v) \in E$}
    \IF {$d(v) > d(u) + c(u,v)$} 
       \STATE $d(v) = d(u) + c(u,v)$ , v pøidáme do  $U$
    \ENDIF
  \ENDFOR
\ENDWHILE
\end{algorithmic}
\end{algorithm}
\par

$U$ reprezentujeme pomocí d-reg. haldy. Pak èas Dijkstrova algoritmu je 
$$
O(|V| \cdot \text{èas na INSERT } + |V| \cdot 
\text{èas na DELETEMIN } + |E| \cdot \text{èas na DESCREASEKEY}) 
$$

Kdy¾ $d = 2$, pak to je $O(|E|log_2(|V|))$
\par
$d = max {\frac{|E|}{|V|}, 2}$, vyjde èas $O(|E|log_d(|V|))$ 
\par
Kdy¾ $\exists \epsilon$ , ¾e $|E| \geq c|V|^{1+\epsilon}$ pro nìjaké $c$,
pak èas je $O(|E|)$. (graf je dostateènì hustý) \\
$|E| \geq c|V|\log^{\epsilon} |V|$ pro nìjaké $c$, $\epsilon$, pak èas je
$O(|E|\log log |V|)$.
\par


\subsection{Heapsort}

Tøídící algoritmus Heapsort je dal¹í aplikací d-regulárních hald.

HEAPSORT - viz alg. \ref{alg:heaps.d-reg.heapsort} 

\begin{itemize}
% XXX odsadit vic doprava, aby nadpisy pro items nepresahovaly
\item[Vstup:] prostá posloupnost prvkù $x_1, x_2, ..., x_n$
\item[Výstup:] uspoøádaná psl. prvkù $x_1, x_2, ..., x_n$
\end{itemize}

\begin{algorithm}[!htb]
\caption{Heapsort pro d-regulární haldy}
\label{alg:heaps.d-reg.heapsort}
\begin{algorithmic}
\STATE MAKEHEAP($x_1, x_2, ..., x_n$)
  \STATE i = 1
  \WHILE {$HEAP \neq \emptyset$}
    \STATE $x_1$ = MIN(HEAP)
    \STATE DELETEMIN(HEAP)
    \STATE i = i + 1
  \ENDWHILE
\end{algorithmic}
\end{algorithm}

\begin{pozn}
Optimum pro d-reg. haldy je nìkde mezi $d=6$ a $d=7$.
\end{pozn}

% --------------------------------------------------------------------------
\section{Leftist haldy}

\begin{defn}
Mìjme binární strom a pro ka¾dého syna máme urèeno, zda je levý nebo
pravý. Pro vrchol v definujeme npl(v) jako délku nejkrat¹í cesty z v do
vrcholu v podstromu v s nejvý¹e jedním synem. 

Binární strom je LEFTIST, kdy¾ 
\begin{itemize}
\item[a)] kdy¾ vrchol $v$ má jednoho syna, pak je to levý syn
\item[b)] kdy¾ vrchol $v$ má dva syny, pak 
	$npl(\text{levého syna}) \geq npl(\text{pravého syna})$
\end{itemize}
\end{defn}

\begin{defn}
Cesta $x_1, x_2, ..., x_n$ se nazývá {\emph pravá}, kdy¾ $x_i$ je pravý syn
$x_{i-1}$ pro $i=2,3,...,n$ a $x_n$ nemá pravého syna.
\end{defn}


Vlastnosti: 
\begin{enumerate}
\item ka¾dý podstrom leftist stromu je leftist 
\item délka pravé cesty z $\forall$ vrcholu $v$ je 
$\leq log(\text{poèet vrcholù v podstromu vrcholu } v)$
\end{enumerate}

\begin{defn}
Letist halda reprezentující mno¾inu $S$ je leftist strom $T$ s $n$ vrcholy
takový, ¾e existuje jednoznaèná korespondence mez prvky $S$ a vrcholy
$T$ taková, ¾e $\forall$ prvek pøiøazený vrcholu $v \geq$ prvek pøiøazený
otci $v$.
\end{defn}

%\begin{pozn}
%Podobné operaci JOIN v AVL stromech (ale...)
% - v AVL stromech je operace JOIN ???
%\mnote{XXX rozvést}
%\end{pozn}

\subsection{MERGE}

Operace MERGE s argumenty $T_1, T_2$ pøedpokládá, ¾e 
$T_1, T_2$ reprezentují disjunktní mno¾iny $S_1, S_2$.
Výsledkem této operace je halda reprezentující $S_1 \cup S_2$.

Formální zápis viz algoritmus \ref{alg:heaps.leftist.merge}

\begin{algorithm}[!htb]
\caption{MERGE pro leftist haldy}
\label{alg:heaps.leftist.merge}
\begin{algorithmic}
\STATE MERGE($T_1$, $T_2$)
\IF {$T_1$ = 0}
  \STATE MERGE($T_1$, $T_2$) $\rightarrow T_2$ konec 
\ENDIF
\IF {$T_2$ = 0}
  \STATE MERGE($T_1$, $T_2$) $\rightarrow T_1$ konec 
\ENDIF
\IF {koøen $T_2$ reprezentuje prvek $<$ prvek repr. koøenem $T_1$}
  \STATE vymìníme $T_1$ a $T_2$
\ENDIF
\STATE pravý syn koøene $T_1 \rightarrow$ MERGE($T_2$, podstrom pravého syna koøene $T_1$)
\IF {npl(levého syna koøene $T_1$) $<$ npl(pravého syna koøene $T_1$)}
  \STATE prohodím syny koøene $T_1$
\ENDIF
\STATE npl(koøene $T_1$) = npl(pravého syna koøene $T_1$) + 1
\STATE MERGE($T_1$, $T_2$) $\rightarrow T_1$ 
\end{algorithmic}
\end{algorithm}

\begin{pozn}
Èasová slo¾itost operace MERGE v leftist haldách je $O(log(n_1+n_2))$, kde
$n_1, n_2$ jsou velikosti reprezentovaných mno¾in.
\end{pozn}

\subsection{INSERT}

viz algoritmus \ref{alg:heaps.leftist.insert}

\begin{algorithm}[!htb]
\caption{INSERT pro leftist haldy}
\label{alg:heaps.leftist.insert}
\begin{algorithmic}
\STATE INSERT(x)
\STATE vytvoøíme novou haldu $T_1$ reprezentující pouze prvek x
\STATE T $\leftarrow$ MERGE($T_1$, $T_2$)
\STATE DELETEMIN
\STATE $T_1 \leftarrow$ podstrom levého syna koøene $T$
\STATE $T_2 \leftarrow$ podstrom pravého syna koøene $T$
\STATE $T$ $\leftarrow$ MERGE($T_1$, $T_2$)
\end{algorithmic}
\end{algorithm}

\begin{theorem}
Operace MIN v leftist haldách vy¾aduje èas $O(1)$, operace MERGE, INSERT, a
DELETEMIN vy¾adují èas $O(log n)$, kde $n$ je poèet prvkù ve výsledné haldì.
\end{theorem}

\begin{pozn}
% XXX obr.
\mnote{XXX obr.}
Podíváme se jak vypadá výsledný strom a podíváme se na vrcholy, se kterými
jsme nìco museli provádìt - tyto vrcholy le¾í na {\emph pravé cestì}, 
tj. je jich omezený poèet.
\end{pozn}

\subsection{DECREASEKEY}

viz algoritmus \ref{alg:heaps.leftist.decreasekey}

\begin{algorithm}[!htb]
\caption{DECREASEKEY pro leftist haldy}
\label{alg:heaps.leftist.decreasekey}
\begin{algorithmic}
\STATE DECREASEKEY($x$)
\STATE odtrhneme podstrom $T_1$ vrcholu $x$, $y$ $\rightarrow$ otec($x$)
\STATE $T_2 = T - T_1$
\STATE zmen¹íme ohodnocení koøene stromu $T_1$
\IF {$y$ má jen pravého syna}
  \STATE zmìníme tohoto syna na levého, $npl(y) = 0$
\ENDIF
\STATE $y \rightarrow otec(y)$
\WHILE {$npl(y) > min\{npl(\text{levý syn }y), npl(\text{pravý syn }y)\} + 1$}
  \IF {$npl(\text{levého syna }y) < npl(\text{pravého syna }y)$}
    \STATE prohodíme syny $y$
  \ENDIF
  \STATE $npl(y) = npl(\text{pravého syna }y) + 1$, $y \rightarrow otec(y)$
\ENDWHILE
\STATE $T \leftarrow$ MERGE($T_1$, $T_2$)
\end{algorithmic}
\end{algorithm}

\begin{pozn}
$npl$, které jsem musel pøepisovat, je v¾dycky pravý syn.
\end{pozn}

\begin{theorem}
Operace DECREASEKEY, INCREASEKEY a DELETE vy¾adují v leftist
haldách èas $O(log n)$. ($n$ je poèet prvkù výsledné reprez. mno¾iny)
\end{theorem}


% --------------------------------------------------------------------------
\section{Binomiální haldy}

\begin{defn}
\emph{Binomiální strom} $B_i$ je rekurzivnì definován jako strom 
sestávající se z
koøene a jeho dìtí $B_0, B_1, ..., B_{i-1}$. Ka¾dý strom má \emph{vlastnost
haldy}, tj. pro ka¾dou stromovou hranu platí $\text{klíè otce} \leq
\text{klíè syna}$.
\end{defn}

\begin{defn}
\label{def.binomheap}
\emph{Binomiální halda} je soubor stromù takových, ¾e
\begin{itemize}
\item ka¾dý strom je izomorfní s nìjakým $B_i$
\item ¾ádné dva stromy nejsou izomorfní
\item existuje jednoznaèná korespondence mezi vrcholy reprezentované
mno¾iny a vrcholy stromù taková, ¾e prvek odpovídající otci je men¹í ne¾
prvek odpovídající vrcholu.
\end{itemize}
\end{defn}

\begin{pozn}
Nejèastìji je binom. halda implementována jako pole ukazatelù, kde $i$-tý
ukazatel ukazuje na koøen stromu $B_i$ nebo je NIL. To, jak dlouhé pole
budeme potøebovat, je kardinální pro amortizovanu slo¾itost. Binární zápis
èísla $n$ má délku $\lfloor log_2 n \rfloor$ $\Rightarrow$ stromy øádu
vy¹¹ího ne¾ $\lfloor log_2 n \rfloor$ se nebudou vyskytovat. (jinak by mìl
graf více ne¾ $n$ vrcholù)

Binomiální stromy rostou exponenciálnì spolu s øádem. (proto funguje
amort. analýza)
\end{pozn}

\begin{pozn}
Na binomiální strom se mù¾eme dívat i jinak: strom $B_i$ sestává ze 2
kopií $B_{i-1}$ (viz obr. \ref{fig.heaps.binomial})
a získá se z nich operací zvanou \emph{spojení}. 
Binomiální haldy souvisí s binomiálním rozvojem èísel.
\end{pozn}

\begin{algorithm}[!htb]
\caption{Spojení dvou binomiálních stromù}
\label{alg:heaps.binom.spoj}
\begin{algorithmic}
\STATE Spojeni($S_1$, $S_2$)
\STATE $S_1, S_2$ jsou stromy izomorfní s $B_i$ pro nìjaké $i$
\IF {prvek reprezentovaný koøenem $S_1 \leq$ prvek reprezentovaný koøenem $S_2$}
  \STATE koøen $S_2$ se stane dal¹ím synem koøene $S_1$
\ELSE
  \STATE koøen $S_1$ se stane dal¹ím synem koøene $S_2$
\ENDIF
\end{algorithmic}
\end{algorithm}

\begin{figure}[!htb]
\centering\includegraphics{pics/binheaps}
\caption{Binomiální stromy}
\label{fig.heaps.binomial}
\end{figure}

\begin{tvrzeni}
Binomiální halda je tvoøena binomiálními stromy $B_i$, které mají následující
vlastnosti: 
\begin{itemize}
\item $B_i$ má $2^i$ vrcholù
\item hloubka $B_i$ je i
\item koøen $B_i$ má i synù
\item $\forall j < i$ existuje syn koøene $B_i$ takový, ¾e 
  jeho podstrom je izomorfní s $B_j$.
\end{itemize}
\end{tvrzeni}

\begin{proof}
indukcí pøes $i$ (elementární)
\end{proof}


\subsection{MERGE}

Algoritmus MERGE (viz algoritmus \ref{alg:heaps.binom.merge}) pracuje jako
"binární sèítání" - 2 stromy $B_i$ (= 2 jednièky v øádu $i$) slije do
$B{i-1}$ (= pøenos do $i+1$)

Pracuje v $O(\log_2 n)$ - nejvy¹¹í mo¾ný øád je $\lfloor \log_2 n \rfloor$.
Toto je slo¾itost v nejhor¹ím pøípadì.

Ukazatel MIN nové haldy je nastaven na men¹í z MIN($h_1$), MIN($h_2$) - to
zabere $O(1)$.


\begin{algorithm}[!htb]
\caption{MERGE pro binomiální haldy}
\label{alg:heaps.binom.merge}
\begin{algorithmic}
\STATE MERGE($T_1$, $T_2$)
\STATE ($T_1, T_2$ binom. haldy velikosti $n_1,n_2$)
\STATE $P = 0, i = 0, T = 0$
\WHILE {$i \leq log(n_1 + n_2)$}
  \STATE $S_1$ je strom v $T_1$ izomorfní s $H_i$ (pokud neexistuje, tak $S_1=0$)
  \STATE $S_1$ je strom v $T_1$ izomorfní s $H_i$ (pokud neexistuje, tak $S_1=0$)
  % XXX \CASE
     \IF {$S_1, S_2$, P = 0}
       \STATE neprovedeme nic
     \ENDIF
     \IF {jeden strom z $S_1, S_2$, $P$ je neprázdný} 
        \STATE vlo¾ím tento strom do $T$, $P=0$
     \ENDIF
     \IF {dva stromy z $S_1, S_2$, $P$ jsou neprázdné}
       \STATE spojím tyto stromy a výsledek vzlo¾ím do $P$
     \ENDIF
     \IF {v¹echny stromy z $S_1, S_2$, $P$ jsou neprázdné}
       \STATE vlo¾ím do $T$, spojení $S_1, S_2$ vlo¾ím do $P$
     \ENDIF
  % \ENDCASE
  \STATE $i = i + 1$
\ENDWHILE
\end{algorithmic}
\end{algorithm}

\begin{pozn}
V algoritmu MERGE (viz algoritmus~\ref{alg:heaps.binom.merge}) 
odpovídá $P$ pøenosu v binárním sèítání, $T$ je výsledná halda.
\end{pozn}

\subsection{MIN}

MIN($h$) - prohledáme prvky reprezentované koøeny stromù a najdeme
nejmen¹í. V praxi je pro ka¾dou haldu dr¾en ukazatel, ukazující na koøen
reprezentující nejmen¹í prvek haldy. Tento ukazatel je obnovován pøi
operaci DELETE\_MIN.


\subsection{INSERT}

Operace INSERT($h$,$i$) se provede pøíkazem MERGE($h$, MAKEHEAP($i$)).
Tato operace je analogická s inkrementací binárního èítaèe.

Dijkstrùv algoritmus provádí na zaèátku $n$ operací INSERT, nám tedy nejde
o jednotlivé operace, ale o posloupnost INSERTù.

\begin{pozn}
INSERT je stejný jako v leftist haldách.
\end{pozn}

\begin{theorem}
Amortizovaná slo¾itost operace INSERT je $O(1)$.
\end{theorem}

\begin{proof}
Vyu¾ijeme úèetní metody: \\
Algoritmus INSERT udr¾uje následující invariant: \\
Ka¾dý binom. strom v haldì má na svém úètu 1 jednotku. (Ten, který
pøestává být koøenem, zaplatí, ten kdo vyhrál, si 1 jednotku ponechal.)
Pøi vytváøení stromu ji zaplatí operace, která strom vytvoøila: 
\begin{itemize}
  \item MAKEHEAP vytvoøí 1 strom $\Rightarrow$ zaplatí 1
  \item DELETE\_MIN vytvoøí $\leq log n$ stromù $\Rightarrow$ zaplatí
  	$\leq log n$
\end{itemize}
Pokud INSERT spustí kaskádu slévání, pak je ka¾dé slití zaplaceno z úètu
stromu, který daným slitím zanikne. (jeho koøen se stane synem)
\end{proof}


\subsection{DELETEMIN}

Operace DELETEMIN (viz algoritmus \ref{alg:heaps.binom.deletemin}) 
je provedena tak, ¾e ze stromu $B_k$, na který ukazuje
ukazatel MIN, utrhneme koøen. Tím vzniknou nové stromy $B_0, B_1, ...,
B_{k-1}$, ze kterých vytvoøíme novou haldu, nastavíme pro ni ukazatel MIN
a zavoláme MERGE.

DELETEMIN pracuje v $O(log_2 n)$, proto¾e $k \leq log_2 n$. Toto je
slo¾itost v nejhor¹ím pøípadì.

\begin{algorithm}[!htb]
\caption{DELETEMIN pro binom. haldu}
\label{alg:heaps.binom.deletemin}
\begin{algorithmic}
\STATE DELETEMIN
\STATE prohledáním prvkù reprezentovaných koøeny stromù naleznu strom $S$,
jeho¾ koøen reprezentuje nejmen¹í prvek
\STATE $T_1 = T \ {S}, T_2$ je tvoøen podstormy v¹echn synù koøene S
\STATE (tj. utrhnu koøen a zbytek dám do haldy) - 
	je to halda díky vlastnosti 4
\STATE $T \rightarrow$ MERGE($T_1, T_2$)
\end{algorithmic}
\end{algorithm}

\begin{pozn}
Operace DELETE se nedá rozumnì provést, museli bychom pøebudovat celý
strom.
\end{pozn}

\begin{theorem}
Operace MERGE, INSERT, MIN, DELETEMIN a DECREASEKEY vy¾adují èas $O(log n)$.
Operace INCREASEKEY vy¾aduje èas $O(log^2 n)$.
\end{theorem}

%\begin{pozn}
%Sèítání v binárních èíslech má slo¾itost $O(1)$.
%
%\begin{tabular}{|l|}
%\hline
%1 0 0 ... 0 \\
%\hline
%1 1 1 ... 1 \\
%\hline
%\end{tabular}
%\hspace{5mm}
%
%XXX amort. slo¾. \\
%Neplatí nìco podobného pro binom. stromy ? Ano, pro operaci INSERT.
%\end{pozn}

\begin{pozn}
MERGE zabírá dost èasu - musíme ho dìlat ?
\end{pozn}


\subsection{Líná implementace binom. hald}

Líná implementace vychází z toho, ¾e chceme operaci MERGE provádìt v èase
$O(1)$.

Zmìníme definici - vynecháme podmínku 2 z definice \ref{def.binomheap}, 
tj. teï v na¹í binom. haldì mohou být izomorfní stromy. (i kdy¾ jen
doèasnì) Dal¹í zmìna
spoèívá ve zmìnì reprezentace binomiální haldy - haldu reprezentujeme
dvojitým kruhovým spojovým seznamem pøes koøeny stromù. (kruhový spojový
seznam umo¾òuje pøidávání a odebírná prvkù v èase $O(1)$.)

Operaci MERGE($T_1, T_2$) pak mù¾eme provést konkatenací seznamù $T_1$ a $T_2$.
Jenom to by nefungovalo, musíme je¹tì zmìnit operace MIN, DELETEMIN.

\begin{algorithm}[!htb]
\caption{DELETEMIN pro líné binom. haldy}
\label{alg:heaps.binom-line.min}
\begin{algorithmic}
\STATE MIN
\STATE pøi prohledávání prvkù reprezentovaných koøeny stromù seøadíme
stromy do mno¾in $Q_i$, $i=0,...,n$ , kde $Q_i$ je mno¾ina v¹ech stromù v
$T$ izomorfních s $B_i$.
\STATE $i = 0, T = 0$
\WHILE {$\exists Q_i \neq 0$}
  \WHILE {$|Q_i| > 1$}
    \STATE vezmeme dva stromy z $Q_i$, spojíme je, výsledek dáme do $Q_{i+1}$
  \ENDWHILE
  \IF {$Q_i \neq 0$}
    \STATE strom z $Q_i$ dám do $T$
  \ENDIF
  \STATE $i = i + 1$
\ENDWHILE
\end{algorithmic}
\end{algorithm}

DELETEMIN umístí stromy po odtr¾ení nejmen¹ího prvku do odpovídajících 
mno¾in $Q_i$. (v mno¾inì $Q_i$ jsou stromy izomorfní s $B_i$)
Poté provede \emph{konsolidaci} - upraví haldu do podoby, kdy je ka¾dý øád
zastoupen nejvý¹e jedním stromem. 

Konsolidace bì¾í v $O(log n)$ plus vyèerpá úèty stromù, které zaniknou pøi
slévání.

\begin{samepage}
Konsolidace probíhá takto:
\begin{enumerate}
  \item vytvoøím pole délky $log n$, které je prázdné 
  	$\Rightarrow$ $O(log n)$
  \item procházím spojový seznam vrcholù stromù v haldì 
  	a jeden strom za druhým vyjmu a 
  	dávám do pole vytvoøeného v kroku 1, pøièem¾ se v¾dy provede 
	pøíslu¹né slití.
	\begin{itemize}
	  \item pokud strom zanikne, tak práci zaplatíme z jeho úètu
	  \item pokud strom nezanikne, tak práci platíme z úètu
	  konsolidace $\rightarrow$ $O(log n)$
	\end{itemize}
  \item z pole vytvoøíme spojový seznam $\rightarrow$ $O(log n)$
\end{enumerate}
\end{samepage}

\begin{samepage}
DELETEMIN tedy potøebuje
\begin{itemize}
  \item $O(log n)$ do úètù novì vytvoøených stromù
  \item $O(log n)$ na jejich zavedení do spojového seznamu
  \item $O(log n)$ na konsolidaci
\end{itemize}
\end{samepage}

Pøi konsolidaci v¾dy zároveò vyhledáme nové minimum.

\begin{theorem}
Operace MERGE a INSERT pøi líné implementaci vy¾adují èas $O(1)$, operace
DELETEMIN a MIN vy¾adují èas $O(\text{poèet stromù v haldì})$.
\end{theorem}

%\begin{pozn}
%$bal(\text{konfigurace}) = \text{poèet v¹ech stromù ve v¹ech haldách v
%konfiguraci}$
%\end{pozn}
%
%\subsubsection{Amort. slo¾.}
%$\text{amort. slo¾.} = \text{èas pro operaci} + 
%bal(\text{výsledné konfigurace}) - bal(\text{pùvodní konfigurace})$

\vspace{5mm}

\begin{center}
\begin{tabular}{|l|l|}
\hline
Operace & Amort. slo¾itost \\
\hline
MERGE & $O(1)$ \\
INSERT & $O(1)$ \\
MIN & $O(log n)$ \\
DELETEMIN & $O(log n)$ \\
\hline
\end{tabular}
\tabcaption{Amortizovaná slo¾itost pro líné binomiální haldy}
\label{tab:binheaps.lazy.complexity}
\end{center}

% \subsection{Zobecnìné binomiální haldy}

% XXX
% \mnote{pøedná¹elo se to tento rok (2004) vùbec ?}

% --------------------------------------------------------------------------
\section{Fibonacciho haldy}

Fibonacciho haldy vycházejí z binomiálních hald, formálnì se li¹í v podstatì
pouze tím, ¾e v haldì povolíme i jiné stromy ne¾ binomiální. Toto nám
umo¾ní implementaci operace DECREASE\_KEY, která nebyla v binomiálních
haldách pøi zachování slo¾itosti ostatních operací mo¾ná.

Øád uzlu a stromu je definován jako u binomiálních hald. Slévání se
provádí pouze mezi stromy stejného øádu.

\subsection{MERGE, INSERT, EXTRACT\_MIN}

Implementace operací MERGE($h_1$,$h_2$), INSERT($h$,$i$), EXTRACT\_MIN($h$) 
je stejná jako u binomiálních hald v "líné" verzi.

\subsection{DECREASE\_KEY}

DECREASE\_KEY provádí sní¾ení hodnoty klíèe pro daný prvek. To se dìje za
cenu pøítomnosti jiných ne¾ binomiálních stromù v haldì.

\begin{algorithm}[!htb]
\caption{DECREASE\_KEY pro Fibonacciho haldy}
\label{alg:heap.fib.decrease_key}
DECREASE\_KEY($h$,$i$,$\delta$)
\begin{enumerate}
  \item sní¾ím klíè prvku $i$ o $\delta$
  \item podstrom i s koøenem $i$ odøízneme a jako samostatný strom ho
        zavedeme haldy (tj. zaøadím do spojového seznamu koøenù stromù v
	haldì) $\Rightarrow$ $O(1)$
  \item Abychom udr¾eli stromy dostateènì "ko¹até"\footnote{nechceme 
  	stromy typu "smeták" - tj. takových, které sestávají pouze 
	z koøene a jeho synù, které jsou zároveò listy}
  	tak od ka¾dého vrcholu $x$ mohou být odøíznuti nejvý¹e 2
  	synové $\Rightarrow$ po odøíznutí 2. syna je odøíznut i sám vrchol $x$.
\end{enumerate}
\end{algorithm}

\begin{figure} 
\centering\includegraphics{pics/fibheaps}
\caption{Poèty vrcholù stromù $F_0, F_1, ...$ tvoøí Fibonacciho
posloupnost.}
\label{fig:heaps.fib.pocty.vrcholu}
\end{figure}

\begin{pozn}
Pøesto¾e jedna operace DECREASE\_KEY mù¾e vyvolat kaskádu øezù, je její
amortizovaná slo¾itost $O(1)$.
\end{pozn}

\begin{pozn}
Pomocí \emph{úèetní metody}\footnote{Pro definici úèetní metody viz
pøedná¹ky ze "\emph{Slo¾itosti a NP úplnosti}".}
doká¾eme, ¾e to platí: \\
Pøi odøezávání syna vrcholu $x$ zaplatí operace DECREASE\_KEY
\begin{samepage}
\begin{itemize}
  \item 2 jednotky na úèet $x$
  \item 1 jednotku na úèet vzniklého stromu
  \item 1 jednotku za práci (odøíznutí a zaøazení)
\end{itemize}
\end{samepage}

Pøi odøíznutí druhého syna jsou na úètu vrcholu $x$ 4 jednotky
$\Rightarrow$ mohu zopakovat body 1) - 3).
\end{pozn}

\begin{theorem}
\label{heaps.fib.theorem}
Nejvy¹¹í øád stromu ve Fibonacciho haldì je $\lfloor log_\varphi n \rfloor =
\Theta(log_2 n)$ pro nìjaké $\varphi > 1$.
\end{theorem}

\begin{lemma}
\label{heaps.fib.lemma}
Nech» $x$ je vrchol a $y_1, ..., y_m$ jeho synové v poøadí, v jakém byli k
$x$ sliti. Potom $\forall \in {1,...,m}$ je øád $y_i$ aspoò $i-2$.
\end{lemma}

\begin{proof}
V okam¾iku, kdy byl $y_i$ slit pod $x$, mìl $x$ øád $\geq i-1$.
($y_1,...,y_{i-1}$ ji¾ v té chvíli byli synové $x$)
V tomto okam¾iku byl také øád $y_{i-1} \geq i-1$. (sléváme pouze stromy
stejného øádu) Od té doby mohl $y_i$ ztratit nejvý¹e jednoho syna, jinak
by byl sám odøíznut a pøestal by být synem $x$. $\Rightarrow$ $y_i$ má øád
$\geq i-2$. 
\end{proof}

\begin{proof}
Dokazujeme vìtu \ref{heaps.fib.theorem}, která jinými slovy øíká: 
Strom øádu $i$ ve
Fibonacciho haldì má velikost alespoò $\varphi^i$ pro nìjaké $\varphi >
1$.

Nech» $F_j$ je nejmen¹í mo¾ný (tj. má oøezané podstromy na max. mo¾nou
úroveò - byl z nich odøíznut 1 syn) strom øádu $j$ splòující tvrzení lemma
\ref{heaps.fib.lemma} a nech» $|F_j| = f_j$. Pak

\begin{enumerate}
  \item $F_i$ vznikne "slitím" $F_{i-1}$ a $F_{i-2}$ $\Rightarrow$ 
  	$f_i = f_{i-1} + f_{i-2}$
  \item $f_i \geq \varphi^i$, kde 
  	$\varphi = \frac{1+\sqrt 5}{2} \approx 1.618$ ... zlatý øez
\end{enumerate}

\begin{itemize}
  \item[ad 1)] 
  viz obr.~\ref{fig:heaps.fib.proof}

  \begin{figure} 
  \centering\includegraphics{pics/fibheap}
  \caption{K dùkazu vìty \ref{heaps.fib.theorem}}
  \label{fig:heaps.fib.proof}
  \end{figure}

  Slití je nepøesný termín - sléváme pouze stromy stejného øádu.
  $F_{i-2}$ je výsledek DECREASE\_KEY. (tím se strom "oholil") Uøíznu
  posledního syna, pod kterým je nejvìt¹í podstrom (abych dostal nejmen¹í
  mo¾ný podstrom)

  \item[ad 2)]
  $\varphi$ je kladý koøen rovnice $x^2 - x - 1 = 0$ \\
  neboli platí $\varphi^2 = \varphi + 1$, $\varphi = \frac{1+\sqrt 5}{2}
  \approx 1.618$ \\
  doká¾eme indukcí: 
    \begin{itemize}
      \item i = 0 : $f_0 = 1 \geq \varphi^0 = 1$
      \item i = 1 : $f_1 = 2 \geq \varphi^1 = 1.618$
      \item indukèní krok: IP: $f_i \geq \varphi^i$, $f_{i+1} \geq
      \varphi^{i+1}$ \\
        $f_{i+2} = f_{i+1} + f_i \geq \varphi^{i+1} + \varphi^i =
	\varphi^i(\varphi + 1) = \varphi^{i+2}$
    \end{itemize}
\end{itemize}
\end{proof}


